import sys
sys.path.append("/opt/mamba/lib/python3.10/site-packages")
import numpy as np
import pandas as pd
import random 
from random import randint
import matplotlib.pyplot as plt
from statistics import mean

sys.path.pop()
sys.path.append("/home/onyxia/projet_info/delivery_network")

from graph import Graph, graph_from_file, catalog_from_file
import trajet_truck

data_path = "/home/onyxia/projet_info/input/network_importation/"
truck_path = "/home/onyxia/projet_info/input/truck/"

"""the budget, which is a contraint"""

B = 25*10**9


def cost_traject_gen(nb_road, nb_truck):
	"""
    This function defines the value of a travel and the cost of the truck to use it

    Parameters:
    -----------
    nb_road: int
        the number of the network studied
    nb_truck: int
        the number of the studied truck file

    Outputs:
    -----------
    value : list
        a list of the value of each travel
    weight : list
        a list of the cost of the truck for each travel
    nb_travel : int
        the number of possible traject
    list_travels : list
        a list of all the possible travels
	"""

	time_road = f"route.{nb_road}.out"
	truck_model = f"trucks.{nb_truck}.in"
	route_name = f"routes.{nb_road}.in"

	cost_and_power_truck = catalog_from_file(truck_path + truck_model)
    
	"""creation of the weight and value list"""

	value = []
	weight = []
	list_travels = []
	list_travel = {}

	with open(data_path + route_name, 'r') as f:
		nb_travel = int(f.readline())
		content = f.readlines()
		for line in content:
			value.append(float(line.split()[2]))
			list_travels.append((int(line.split()[0]), float(line.split()[1])))

	with open(data_path + time_road, 'r') as f:
        
		content = f.readlines()
		key_travel = 0
		for line in content:
			i = 0 
			min_power = float(line.split()[0])
			while cost_and_power_truck[i][0] < min_power:
				i = i+1
        
			cost_travel = cost_and_power_truck[i][1]
			weight.append(cost_travel)
			list_travel[key_travel] = (list_travels[key_travel], i+1)
			key_travel = key_travel + 1

	return value, weight, nb_travel, list_travels

def close_solution_with_greedy(nb_road, nb_truck,nb_travel, B):

	"""
    This function gets a first solution throught a greedy algorithm and creates then the individu associated to this 
    solution
    
	Parameters:
	-----------
	nb_road: int
	    the number of the network studied
	nb_truck: int
	    the number of the studied truck file
	nb_travel : int
		the number of possible travel, i.e the lenght of the chromosome
	B : int
		the budget, which is here a constraint 
	
	Outputs: 
	-----------
	individual  : list
		a list of 0 and 1 representing the chromosome of an individual
	"""

	"""loading the allocation generated by the greedy algorihm"""
	_,allocation, _, _, _ = trajet_truck.knapsack_greedy(nb_road, nb_truck, B)

	"""creation of the individu"""
	individual = [0]*nb_travel
	for travel in allocation : 
		individual[travel[2] - 1] = 1

	return individual

def generate_population(nb_road, nb_truck, size, nb_travel, B):
	"""
    This function generates a population of individuals, whose size is nb_travel. The number of people is egal tp size
    Some individuals are added from the beggining accoridng to some particularities 
	Parameters:
    -----------
    
    nb_road: int
        the number of the network studied
    nb_truck: int
        the number of the studied truck file
    size: int
        number of people in the population
    nb_travel : int
        the number of possible travel, i.e the lenght of the chromosome
    B : int
        the budget, which is here a constraint
    
	Outputs :
	-----------
        population: list
            a list of size size, which contains indiviual represented by a list
	"""
    
	population = []
	"""creation of the number of individuals generated by the colse solution"""
	nb_super_individu = int(0.2*size)
	"""generation of random individuals"""
	for individu in range(size - 1- nb_super_individu):
		genes = [0,0,0,0,1]
		chromosome = []
        
		for i in range(nb_travel):
			chromosome.append(random.choice(genes))
		population.append(chromosome)
        
	
	"""the individuals generated by the close solution are added"""
	super_individu = close_solution_with_greedy(nb_road, nb_truck, nb_travel, B)
	for i in range(nb_super_individu): 
		population.append(super_individu)

	print("Generated a random population of size", size)
	return population

def calculate_fitness(chromosome, weight, value, B):
	"""
	This function calculates the fitness of a chromosome according to the constraint B. It defines how good
	the solution associated with the chromsome is.

	Parameters:
	-----------  
	chromosome  : list
	    a list of 0 and 1 representing the chromosome of an individual
	value : list
	    a list of the value of each travel
	weight : list
	    a list of the cost of the truck for each travel
	B : int
	    the budget, which is here a constraint.

	Ouputs
	----------
	total_value : float
		fitness of the chromosome

	"""
	total_weight = 0
	total_value = 0
	for i in range(len(chromosome)):
		if chromosome[i] == 1:
			total_weight += weight[i]
			total_value += value[i]
	if total_weight > B:
		return 0
	else:
		return total_value

def probability_reproduction(population, weight, value, B) : 
	"""this function calculates the fitness value of each individual in the population"""
	"""
	Parameters:
    -----------
    population: list
        a list of size size, which contains indiviual represented by a list
    value : list
        a list of the value of each travel
    weight : list
        a list of the cost of the truck for each travel
    B : int
	budget, which is here a constraint

	Outputs:
	-----------
	fitness_values : list
		list of the fitness values of each individual in the population

	"""
	fitness_values = []
	for parent in population:
		fitness_values.append(calculate_fitness(parent, weight, value, B))
	
	fitness_values = [float(i)/(sum(fitness_values)) for i in fitness_values]
	return fitness_values

def select_parent(population, fitness_values):
	"""this function selects two parents, with a probablity linked to their fitness

	Parameters:
	-----------
	population: list
	    a list of size size, which contains indiviual represented by a list
	fitness_values: list
		list of the fitness values of each individual in the population     

	Outputs: 
	-----------
	parent1: list
		a list of 0 and 1 representing the chromosome of an individual
	parents2:list
		a list of 0 and 1 representing the chromosome of an individual
	"""
	parent1 = random.choices(population, weights=fitness_values, k=1)[0]
	parent2 = random.choices(population, weights=fitness_values, k=1)[0]
	
	return parent1, parent2

def crossover(parent1, parent2, nb_travel):

	"""
	this function implements the crossover operation between two parents. Two parents are
	randomly selected and two childs are created by mixing them throught a random operation
	Parameters:
	-----------
	parent1: list
		a list of 0 and 1 representing the chromosome of an individual
	parents2:list
		a list of 0 and 1 representing the chromosome of an individual
	nb_travel : int
		the number of possible travel, i.e the lenght of the chromosome

	Outputs
	-----------
	child1: list
	a list of 0 and 1 representing the chromosome of an individual
	child2:list
	a list of 0 and 1 representing the chromosome of an individual
	"""

	crossover_point = random.randint(0, nb_travel -1)
	child1 = parent1[0:crossover_point] + parent2[crossover_point:]
	child2 = parent2[0:crossover_point] + parent1[crossover_point:]

	return child1, child2

def mutate(child, mutation_probabilty, nb_travel):

    """
    Parameters:
    -----------
    
    child: list
        a list of 0 and 1 representing the chromosome of an individual
    mutation_probabilty: float
        probabilty that a gene (i.e an element of the chromosome) changes
    nb_travel : int
        the number of possible travel, i.e the lenght of the chromosome
        
    Outputs
    -----------
    child: list
        a list of 0 and 1 representing the chromosome of an individual
    
    """
    
    """iterartion of the mutatation change"""
    for i in range (int(mutation_probabilty*nb_travel)):
        """random choice of a gene"""
        mutation_point = random.randint(0, nb_travel-1)
        """mutation of the gene"""
        if child[mutation_point] == 0:
            child[mutation_point] = 1
        else:
            child[mutation_point] = 0
    return child

def selection_elitist(population, fitness_values, n_elites):

	"""
	this function implemnts elitism : the best individuals are certain to reproduce. Hence it
	selects the best individuals

	Parameters:
	-----------
	population: list
		a list of size size, which contains indiviual represented by a list
	fitness_values : list
		list of the fitness values of each individual in the population
	n_elites: int
		the number of elite people,i.e the ones with the best fitness)

	Outputs
	-----------
	elite : list
		a list of n_elites elements containing the elite people
	"""

	"""Sort the population and fitness_values lists by fitness value in descending order"""
	sorted_population = [x for _, x in sorted(zip(fitness_values, population), reverse=True)]
	sorted_fitness = sorted(fitness_values, reverse=True)

	"""Select the n_elites best chromosomes"""
	elites = sorted_population[:n_elites]
	
	return elites

def	remplacement(population, fitness_values, n_elites, elites): 

	"""
	the worst indivuals in a population are remplaced by elite individuals in the process
	of elitism

	Parameters:
	-----------
	population: list
		a list of size size, which contains indiviual represented by a list
	fitness_values : list
		list of the fitness values of each individual in the population
		n_elites: int
		 the number of elite people,i.e the ones with the best fitness)
	elite : list
		a list of n_elites elements containing the elite people
	n_elites: int
		the number of elite people,i.e the ones with the best fitness)

	Outputs
	-----------
	population: list
		a list of size size, which contains indiviual represented by a list
	"""

	"""The elite individuals are added"""
	sorted_population = [x for _, x in sorted(zip(fitness_values, population), reverse=True)]
	population[-n_elites:] = elites
	"""Return the updated population"""
	return population

def get_best(population,weight,value,B):

	"""find the best individual in the population

	
    Parameters:
    -----------
    population: list
        a list of size size, which contains indiviual represented by a list
    value : list
        a list of the value of each travel
    weight : list
        a list of the cost of the truck for each travel
        
    Outputs:
    -----------
    -----------
    best_individual: 
        a list of 0 and 1 representing the chromosome of the best individual
    """
	
	"""calculate fitness"""
	fitness_values = []
	for individu in population:
		fitness_values.append(calculate_fitness(individu, weight, value, B))
        
	"""find the best_individual"""
	max_value = max(fitness_values)
	max_index = fitness_values.index(max_value)
	best_individual = population[max_index]
	return best_individual

def simulation(nb_road, nb_truck, size_population, mutation_probability, number_generation, percentage_elitism, B):
	"""
	Parameters:
	-----------
	nb_road: int
		the number of the network studied
	nb_truck: int
		the number of the studied truck file 
	size_population : int
		the number of individuals in the population
	mutation_probability : float
		probability of a mutation
	number_generation: int
		number of generations generated
	percentage_elitism: percentage
	    percentage of people who are elitism
	B : int
		budget, which is here a constraint
	
	Outputs:
	-----------

	total_value: float
	allocation, 
	nb_travels, 
	total_weight
	
	nb_road: int
	the number of the network studied

	nb_truck: int
        the number of the studied truck file
	"""

	print("the search has begun")
	value, weight, nb_travel, list_travel = cost_traject_gen(nb_road, nb_truck)
	
	n_elites = int(nb_travel*percentage_elitism)
	population = generate_population(nb_road, nb_truck, size_population, nb_travel, B)



	for generation in range(number_generation):
		print("une nouvelle génération a commencé")
		fitness_values = probability_reproduction(population, weight, value, B)
		elites = selection_elitist(population, fitness_values, n_elites)
		new_population = []

		for child in range(size_population//2): 
			
			parent1, parent2 = select_parent(population, fitness_values)
			
			child1, child2 = crossover(parent1, parent2, nb_travel)
			new_population.append(child2)

			child1 = mutate(child1, mutation_probability, nb_travel)

			new_population.append(child1)
			
		

		
		fitness_values = probability_reproduction(new_population, weight, value, B)
		population = remplacement(new_population, fitness_values, n_elites, elites)
		the_chosen_one = get_best(population, weight, value, B)
		
			
	total_value = 0
	total_weight = 0
	
	allocation	 = []
	nb_travels = 0
	for i in range(nb_travel):
		if the_chosen_one[i] == 1:
			total_value += the_chosen_one[i]*value[i]
			total_weight += the_chosen_one[i]*weight[i]
			allocation.append(list_travel[i])
			nb_travels += 1
	return total_value, allocation, nb_travels, total_weight



B = 25*10**9

result = simulation(10, 2, 10, 0.1, 10, 0.01, B)
result_control = trajet_truck.knapsack_greedy(1, 2, B)
print(result[0])
print(result_control[0])
print(result[2])
print(result_control[3])
print(100*result[3]/B)
print(100*result_control[4]/B)
print("a")








